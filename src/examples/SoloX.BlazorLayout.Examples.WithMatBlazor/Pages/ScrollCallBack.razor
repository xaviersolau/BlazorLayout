@page "/ScrollCallBack"


@inject IScrollObserverService scrollObserverService

@implements IScrollCallBack
@implements IAsyncDisposable

<DockContainer Fill="Fill.Full" Proportion="30">
    <DockPanel Side="Core.Side.Left">
        <MatHeadline6 Style="margin:0px;">
            Let's register a scroll callback!
        </MatHeadline6>
        <MatBody1 Style="margin:0px;">
            Scroll is @scroll <br>
            Height is @scrollHeight <br>
            View Height is @scrollViewHeight
        </MatBody1>

        <MatButton @onclick="@GoToTheTop">
            Got to the top
        </MatButton>
    </DockPanel>

    <BoxContainer @ref="ContainerReference" Fill="Fill.Full">
        <BoxContainer  Class="panel-container" Fill="Fill.Horizontal" Style="height: 300px; background-color: chocolate;">
            Box1
        </BoxContainer>
        <BoxContainer Class="panel-container" Fill="Fill.Horizontal" Style="height: 300px; background-color: cornflowerblue;">
            Box2
        </BoxContainer>
        <BoxContainer Class="panel-container" Fill="Fill.Horizontal" Style="height: 300px; background-color: burlywood;">
            Box3
        </BoxContainer>
        <BoxContainer Class="panel-container" Fill="Fill.Horizontal" Style="height: 300px; background-color: gray;">
            Box4
        </BoxContainer>
        <BoxContainer Class="panel-container" Fill="Fill.Horizontal" Style="height: 300px; background-color: bisque;">
            Box5
        </BoxContainer>
    </BoxContainer>

</DockContainer>


@code {
    private BoxContainer ContainerReference { get; set; }

    private int scroll;
    private int scrollHeight;
    private int scrollViewHeight;

    private IAsyncDisposable callBackDisposable;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            callBackDisposable = await scrollObserverService.RegisterScrollCallBackAsync(this, ContainerReference.ElementReference);
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    public ValueTask ScrollAsync(ScrollInfo scrollInfo)
    {
        this.scroll = scrollInfo.Top;
        this.scrollHeight = scrollInfo.Height;
        this.scrollViewHeight = scrollInfo.ViewHeight;

        this.StateHasChanged();

        return ValueTask.CompletedTask;
    }

    private async Task GoToTheTop()
    {
        await scrollObserverService.ScrollToAsync(ContainerReference.ElementReference, null, 0);
    }

    public async ValueTask DisposeAsync()
    {
        if (this.callBackDisposable != null)
        {
            await callBackDisposable.DisposeAsync();
            this.callBackDisposable = null;
        }
    }
}
